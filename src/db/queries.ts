import { drizzle } from "drizzle-orm/d1";
import { eq, inArray, desc, asc } from "drizzle-orm";
import { memories } from "./schema";

/**
 * Creates a Drizzle ORM instance from a Cloudflare D1 database binding.
 * Use this to start a database session.
 *
 * @param d1 - The D1Database binding from the worker environment.
 * @returns A configured Drizzle ORM instance.
 */
export const createDb = (d1: D1Database) => drizzle(d1);

/**
 * Type definition for inserting a new memory row.
 * Infers types directly from the Drizzle schema.
 */
export type InsertMemory = typeof memories.$inferInsert;

/**
 * Type definition for selecting a memory row.
 * Infers types directly from the Drizzle schema.
 */
export type SelectMemory = typeof memories.$inferSelect;

/**
 * Inserts a single memory record into the database.
 *
 * @param d1 - The D1Database binding.
 * @param memory - The memory object to insert. Must match the schema structure.
 * @returns The result of the insert operation (D1Result).
 *
 * @example
 * await createMemory(env.DB, {
 *   id: crypto.randomUUID(),
 *   text: "Remember to buy milk",
 *   createdAt: Date.now(),
 *   status: "raw"
 * });
 */
export const createMemory = async (d1: D1Database, memory: InsertMemory) => {
  const db = drizzle(d1);
  return db.insert(memories).values(memory).run();
};

/**
 * Retrieves multiple memories by their unique IDs.
 * useful for hydrating vector search results.
 *
 * @param d1 - The D1Database binding.
 * @param ids - An array of memory IDs (strings) to fetch.
 * @returns An array of memory objects matching the provided IDs.
 *          Returns an empty array if the input `ids` list is empty.
 */
export const getMemoriesByIds = async (d1: D1Database, ids: string[]) => {
  if (ids.length === 0) return [];
  const db = drizzle(d1);
  return db.select().from(memories).where(inArray(memories.id, ids)).all();
};

/**
 * Fetches "raw" memories that have not yet been processed or consolidated.
 * Used by the curator agent to find candidates for deduplication/merging.
 *
 * @param d1 - The D1Database binding.
 * @param limit - The maximum number of memories to retrieve (default: 20).
 *                Limit is important to prevent worker timeouts.
 * @returns An array of memory objects ordered by creation date (oldest first).
 */
export const getRawMemories = async (d1: D1Database, limit = 20) => {
  const db = drizzle(d1);
  return db
    .select()
    .from(memories)
    .where(eq(memories.status, "raw"))
    .orderBy(asc(memories.createdAt))
    .limit(limit)
    .all();
};

/**
 * Marks a memory as "processed" without modifying its content.
 * This indicates the memory was analyzed but not merged/changed.
 *
 * @param d1 - The D1Database binding.
 * @param id - The ID of the memory to update.
 * @returns The result of the update operation.
 */
export const markMemoryProcessed = async (d1: D1Database, id: string) => {
  const db = drizzle(d1);
  return db
    .update(memories)
    .set({ status: "processed" })
    .where(eq(memories.id, id))
    .run();
};

/**
 * Updates a memory with new consolidated text and marks it as "consolidated".
 * This is called when multiple similar memories are merged into one.
 * Also updates the `updatedAt` timestamp.
 *
 * @param d1 - The D1Database binding.
 * @param id - The ID of the memory to update (the survivor).
 * @param newText - The new, consolidated text generated by the LLM.
 * @returns The result of the update operation.
 */
export const updateConsolidatedMemory = async (
  d1: D1Database,
  id: string,
  newText: string
) => {
  const db = drizzle(d1);
  return db
    .update(memories)
    .set({
      text: newText,
      status: "consolidated",
      updatedAt: Date.now(),
    })
    .where(eq(memories.id, id))
    .run();
};

/**
 * Deletes multiple memories from the database.
 * Used to remove redundant memories after they have been consolidated into a survivor.
 *
 * @param d1 - The D1Database binding.
 * @param ids - An array of memory IDs to delete.
 * @returns The result of the delete operation.
 */
export const deleteMemories = async (d1: D1Database, ids: string[]) => {
  if (ids.length === 0) return;
  const db = drizzle(d1);
  return db.delete(memories).where(inArray(memories.id, ids)).run();
};
